---
title: 6. Kubernetes and AWS EKS
pubDate: 2024-02-26
description: 'AWS EKS 의 이점과 함께 Kubernetes Cluster 를 설정하는 방법에 대해 설명합니다.'
heroImage: "../../../assets/heroes/kubernetes-eks.png"
---

## Kubernetes 의 활용

애플리케이션 급속하게 성장함에 따라, 증가하는 수요를 충족시키면서 동시에 신뢰성 및 효율성을 유지하는 인프라의 확장에 대한 도전을 종종 마주하게 됩니다.
Kubernetes 는 컨테이너화된 애플리케이션의 배포, 스케일링 및 관리를 자동화하는 강력한 시스템을 제공하며 해결책으로 등장합니다.

그 특징으로는:
- **스케일러빌리티:** 자동으로 애플리케이션을 스케일 업 또는 다운시켜 변동하는 워크로드에 신속하게 조정합니다.
- **일관성 및 이식성:** 개발, 테스트, 생산 환경에서 일관된 환경을 보장하며, 클라우드 및 온프레미스 시스템 간의 원활한 마이그레이션 및 배포를 용이하게 합니다.
- **고가용성:** 자가 치유 기능으로 애플리케이션의 가동 시간을 최대화하며, 실패한 컨테이너 및 노드를 자동으로 교체합니다.
- **자원 효율성:** 기반 인프라의 사용을 최적화하여 비용을 줄이고 컨테이너 오케스트레이션을 통해 성능을 향상시킵니다.

## Managed Kubernetes 를 통한 운영

복잡한 Kubernetes 초기설정을 간소화하고 각 Cloud Service 에 최적화된 환경을 구성하기 위해 Managed Kubernetes 를 사용할 수 있습니다.
AWS 에서는 EKS, Azure 에서는 AKS, GCP 에서는 GKE 등이 있으며, 이러한 서비스는 클러스터의 배포, 관리, 스케일링 및 모니터링을 단순화하고, 클라우드 서비스와의 통합을 통해 애플리케이션의 성능, 보안, 확장성을 향상시킵니다.
이 포스트에서는 AWS EKS 는 Kubernetes 를 사용하여 컨테이너화된 앱의 배포, 관리, 스케일링을 간소화하는 과정을 설명합니다.

- **완전 관리형 컨트롤 플레인:** EKS 는 자체적으로 완전 관리형 컨트롤 플레인을 제공하여 Kubernetes 관리의 복잡성을 줄이고, 클러스터의 배포, 관리, 스케일링 및 모니터링을 단순화합니다.
- **통합된 생태계:** AWS 서비스와의 원활한 통합을 통해 EKS 는 애플리케이션의 성능, 보안, 확장성을 향상시키며, 네트워킹부터 보안에 이르기까지 종합적인 솔루션을 위한 AWS 의 생태계를 활용합니다.
- **접근제어:** EKS 는 보안을 염두에 두고 설계되었으며 IAM 을 통한 세분화된 접근 제어를 통해 보안 기준을 충족하도록 합니다.
- **하이브리드 운영 지원:** 하이브리드 접근 방식을 가능하게 하여 온프레미스로 구동중인 기존 워크플로를 방해하지 않으면서 클라우드에서 Kuberenetes 를 사용할 수 있도록 합니다.

### AWS EKS 준비하기

원활한 AWS Elastic Kubernetes Service (EKS) 클러스터 구성을 위해 선행되어야 하는 사항들입니다.

#### AWS EKS 에 대한 필수 요건

- **AWS 계정 설정:** 활성화된 AWS 계정이 필요합니다.
- **IAM 역할 및 정책:** 초기 원활한 진행을 위해 AWS Root 계정 또는 AdministratorAccess 정책이 첨부된 계정을 이용한 진행을 권장합니다. 프로덕션 환경에서는 AWS Identity and Access Management (IAM)을 이해하여 EKS 클러스터에 대한 접근을 보안하고 관리하세요.

#### 도구

- **eksctl:** EKS 클러스터를 생성하고 관리하기 위한 간단한 CLI 도구입니다. eksctl 은 EKS 클러스터를 설정하는 데 필요한 많은 복잡성과 boiler plate 코드를 추상화합니다.
- **AWS CLI:** AWS Command Line Interface 는 AWS 서비스와 상호 작용하는 데 필수적입니다. 원활한 진행을 위해 AWS Root 계정 또는 AdministratorAccess 정책이 첨부된 계정을 이용한 진행을 권장합니다.
- **kubectl:** Kubernetes cli 도구입니다. 설치후 eksctl 을 이용하여 클러스터를 구성하게 되면 자동으로 해당 클러스터에 대한 kubectl 실행 환경이 설정됩니다.
- **AWS Management Console:** AWS Management Console 을 통해 EKS 및 다른 AWS 서비스에 대한 접근 및 관리를 할 수 있습니다. 진행 확인을 보다 쉽게 하기 위해 필요합니다.

#### 초기 구성 단계

1. **AWS CLI 구성:** AWS CLI 사용을 위해 계정을 설정합니다.

```sh
aws configure
```

2. **eksctl 설치:** 공식 문서를 따라 로컬 기기에 eksctl 을 설치하세요. eksctl 은 EKS 클러스터와 관련된 많은 작업을 단순화합니다.

MacOS
```sh
brew tap weaveworks/tap
brew install weaveworks/tap/eksctl
```
그 외 os 는 공식 [eksctl 설치문서](https://eksctl.io/installation/) 참조하여 설치하세요.

3. **kubectl 설치:** kubectl이 설치되어 있는지 확인하세요. 이것은 Kubernetes 클러스터와 상호 작용하기 위한 주요 도구가 될 것입니다.

```sh
# MacOS용
brew install kubectl
````
그 외 os 는 공식 [kubectl 설치문서](https://kubernetes.io/ko/docs/tasks/tools/) 참조하여 설치하세요.

Docker Desktop 을 이용하여 kubernetes 를 사용할 경우, eksctl 을 이용해 클러스터를 생성하면 자동으로 kubectl 환경이 설정됩니다.

### EKS 클러스터 생성을 위한 단계별 가이드

1. **EKS 클러스터 초기화:**

`eksctl`을 사용하여 EKS 클러스터를 생성합니다.
클러스터 이름, 지역, 노드 사양을 필요에 따라 설정할 수 있습니다.

```yaml
apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: my-cluster
  region: ap-northeast-2
  version: "1.28"

managedNodeGroups:
  - name: my-nodegroup
    amiFamily: AmazonLinux2
    instanceType: t4g.small
    desiredCapacity: 2
    minSize: 1
    maxSize: 3
    volumeSize: 20
    volumeType: gp3
    ssh:
      allow: true # '모두로부터의 원격 접근 허용'과 일치
      publicKeyName: <your-key>
    privateNetworking: false # 개인 서브넷만 사용하려면 true로 설정
    labels: { role: worker }
    tags:
      "k8s.io/cluster-autoscaler/enabled": "true"
      "k8s.io/cluster-autoscaler/my-cluster": "owned"
```

- **apiVersion**: `eksctl.io/v1alpha5`는 `eksctl` 구성 파일 포맷의 버전을 지정합니다. 파일이 `eksctl`이 이해하는 특정 구문을 사용한다는 것을 나타냅니다.
- **kind**: `ClusterConfig`는 문서가 EKS 클러스터에 대한 구성임을 나타냅니다.
- **metadata**:
    - `name`: EKS 클러스터에 주어진 이름입니다.
    - `region`: 클러스터가 배포될 AWS 지역을 지정하며, 이 경우는 서울, 대한민국입니다.
    - `version`: 클러스터의 쿠버네티스 버전을 나타냅니다.

- **managedNodeGroups**: EKS 에 의해 관리되는 노드 그룹 목록을 정의합니다. 각 노드 그룹은 독립적으로 스케일할 수 있으며 다른 인스턴스 유형을 가질 수 있습니다. 이 구성에서는 하나의 관리되는 노드 그룹이 있습니다:
    - `name`: `my-nodegroup`는 노드 그룹의 이름입니다.
    - `amiFamily`: 이 그룹의 노드의 운영 체제를 지정합니다.
    - `instanceType`: 노드안에 소속된 머신의 EC2 인스턴스 유형입니다.
    - `desiredCapacity`: 노드 그룹의 초기 인스턴스 수입니다.
    - `minSize`: 노드 그룹의 최소 인스턴스 수를 보장합니다.
    - `maxSize`: 노드 그룹이 확장할 수 있는 최대 인스턴스 수입니다.
    - `volumeSize`: 각 노드에 첨부된 EBS 볼륨의 크기입니다.
    - `volumeType`: EBS 볼륨의 유형입니다.
    - `ssh`: 노드에 대한 SSH 접근을 정의합니다.
        - `allow`: `true`는 노드에 대한 SSH 접근을 활성화합니다.
        - `publicKeyName`: 노드에 접근하기 위해 사용될 SSH 키의 이름입니다.
    - `privateNetworking`: `false`는 노드가 공용 서브넷을 사용할 것임을 나타냅니다. `true` 로 설정하면 인터넷에 직접 노출되지 않도록 개인 서브넷에 배치됩니다.
    - `labels`: 노드 그룹의 노드에 대한 Kubernetes 라벨을 정의합니다. 여기에서는 `role: worker`가 설정되어 있으며, 이를 사용하여 특정 작업을 이 노드에 할당할 수 있습니다.
    - `tags`: 노드 그룹에 대한 태그를 지정할 수 있습니다. 태그를 지정함으로 클러스터 관리할 수 있도록 합니다.
        - `"k8s.io/cluster-autoscaler/enabled": "true"`는 이 노드 그룹에 대해 클러스터 자동 스케일러를 활성화합니다.
        - `"k8s.io/cluster-autoscaler/my-cluster": "owned"`는 노드 그룹이 `my-cluster` 클러스터의 일부로 태그되어 있어 클러스터 자동 스케일러가 관리할 수 있도록 합니다.

아래 명령어를 통해 클러스터를 생성합니다. 클러스터를 생성하는데 수 분 이상의 시간이 소요될 수 있습니다.

```sh
eksctl create cluster -f cluster.yaml
```

2. **클러스터 생성 확인:**

생성 프로세스가 완료되면 `eksctl` 및 `kubectl`을 사용하여 클러스터 상태를 확인하세요.

```sh
eksctl get cluster --name your-cluster-name
kubectl get svc -A
```
#### 샘플 애플리케이션 배포

EKS 클러스터에 간단한 nginx 웹 서버를 배포하여 정상적으로 작동하는지 확인합니다.

1. **Deployment 생성:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

이 구성을 `nginx-deployment.yaml` 파일로 저장하고 `kubectl`을 사용하여 적용하세요.

```sh
kubectl apply -f nginx-deployment.yaml
```

배포 확인

```sh
kubectl get pods
```

2. **애플리케이션 노출:**

인터넷에 애플리케이션을 노출하기 위한 서비스를 생성하세요.

```sh
kubectl expose deployment nginx-deployment --port=80 --type=LoadBalancer
```

이 명령은 LoadBalancer 서비스를 생성하여, nginx 애플리케이션에 접근할 수 있는 외부 IP 주소를 제공합니다.
그리고 AWS는 Classic LoadBalancer를 생성하고 그것에 공용 IP 주소를 할당할 것입니다.

서비스 확인

```sh
kubectl get svc
```

외부 IP 주소가 보이면, 웹 브라우저에서 IP 주소를 입력하여 nginx 애플리케이션에 접근할 수 있습니다.
이 프로세스는 로드 밸런서를 생성하고 IP 주소를 할당하는 데 시간이 걸릴 것입니다.

### 리소스 정리

사용했던 클러스터 내용을 모두 삭제합니다. 클러스터 삭제는 수 분 이상의 시간이 소요될 수 있으며 삭제가 실패할 경우 직접 AWS Console 에서 원인을 파악후 삭제를 진행해야합니다.

```sh
eksctl delete cluster --name your-cluster-name --disable-eviction
```

#### 요약

Kubernetes를 채택하여 성장하는 회사에 대한 첫 번째 EKS 클러스터를 배포하는 것은 중요한 이정표입니다. 이 장에서 설명한 단계를 따라서, 애플리케이션을 위한 확장 가능하고 보안된 환경을 생성했습니다. 귀사의 c

## 참조

- 도서 `Mastering Elastic Kubernetes Service on AWS`
- AWS EKS 문서
- https://eksctl.io/

